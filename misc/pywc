#!/usr/bin/env python

import argparse
import sys


# Args holds the command-line flags
class Args:
    def __init__(self):
        self.c = False
        self.m = False
        self.w = False
        self.l = False


# OutputData stores statistics for a single file
class OutputData:
    def __init__(self, file=""):
        self.file = file
        self.lines = 0
        self.words = 0
        self.characters = 0
        self.bytes = 0


output_data = []  # Stores statistics for all files
total = OutputData("total")  # Accumulates totals across all files
args = Args()  # Global variable for command-line flags

max_lines_width = max_words_width = max_chars_width = max_bytes_width = (
    0  # Widths for column formatting
)


def parse_flags():
    parser = argparse.ArgumentParser(
        description="Count lines, words, characters, and bytes in files."
    )
    parser.add_argument("-c", action="store_true", help="print the byte counts")
    parser.add_argument("-m", action="store_true", help="print the character counts")
    parser.add_argument("-w", action="store_true", help="print the word counts")
    parser.add_argument("-l", action="store_true", help="print the newline counts")
    parser.add_argument(
        "files",
        nargs="*",
        help="Files to process, or read from standard input if none are provided",
    )
    return parser.parse_args()


def calculate_stats(file, file_path):
    global max_lines_width, max_words_width, max_chars_width, max_bytes_width

    data = OutputData(file_path)
    line_buffer = ""

    for line in file:
        data.bytes += len(line.encode("utf-8"))
        data.lines += 1
        data.characters += len(line.rstrip("\n"))
        data.words += len(line.split())

    # Handle the case where the last line does not end with a newline
    if line_buffer:
        data.characters += len(line_buffer)
        data.words += len(line_buffer.split())

    # Update totals
    total.lines += data.lines
    total.words += data.words
    total.characters += data.characters
    total.bytes += data.bytes

    # Update maximum widths for formatting
    max_lines_width = max(max_lines_width, len(str(data.lines)))
    max_words_width = max(max_words_width, len(str(data.words)))
    max_chars_width = max(max_chars_width, len(str(data.characters)))
    max_bytes_width = max(max_bytes_width, len(str(data.bytes)))

    output_data.append(data)


def get_max_width():
    max_width = 0
    if args.l:
        max_width = max(max_width, max_lines_width)
    if args.w:
        max_width = max(max_width, max_words_width)
    if args.c:
        max_width = max(max_width, max_chars_width)
    if args.m:
        max_width = max(max_width, max_bytes_width)
    if not (args.l or args.w or args.c or args.m):
        max_width = max(max_lines_width, max_words_width, max_bytes_width)
    return max_width


def print_output():
    width = get_max_width()  # Get the maximum width for formatting

    for data in output_data:
        output = []

        if args.l:
            output.append(f"{data.lines:>{width}}")
        if args.w:
            output.append(f"{data.words:>{width}}")
        if args.m:
            output.append(f"{data.characters:>{width}}")
        if args.c:
            output.append(f"{data.bytes:>{width}}")
        if not (args.l or args.w or args.m or args.c):
            output.append(f"{data.lines:>{width}}")
            output.append(f"{data.words:>{width}}")
            output.append(f"{data.bytes:>{width}}")

        if data.file:
            output.append(data.file)

        print(" ".join(output))


def main():
    global args
    args = parse_flags()  # Parse command-line flags

    files_path = args.files

    if not files_path:
        # No file paths provided, read from standard input
        calculate_stats(sys.stdin, "")
        print_output()
    else:
        # Process each file path provided
        for file_path in files_path:
            try:
                with open(file_path, "r", encoding="utf-8") as file:
                    calculate_stats(file, file_path)
            except IOError as e:
                print(f"Error opening file: {file_path}: {e}", file=sys.stderr)
                continue

        if len(files_path) > 1:
            # Add a total line if more than one file is processed
            output_data.append(total)

        print_output()


if __name__ == "__main__":
    main()
